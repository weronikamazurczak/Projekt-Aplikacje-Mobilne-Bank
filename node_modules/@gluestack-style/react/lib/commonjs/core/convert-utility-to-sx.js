"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertUtilityPropsToSX = exports.checkAndReturnUtilityProp = void 0;
var _utils = require("./../core/utils");
var _convertSxToSxVerbosed = require("../convertSxToSxVerbosed");
var _styledSystem = require("./styled-system");
const getSxPropsPathFromProp = function (propString, reservedKeys) {
  let descendants = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  const propsPath = propString.split('-');
  let responsiveProp = '';
  let isInvalidPropString = false;
  const propToBeApplied = propsPath.pop();
  const gsConvertedPropsPath = [];
  propsPath.forEach(prop => {
    if (reservedKeys[prop]) {
      var _reservedKeys$prop;
      const isMediaQuery = (_reservedKeys$prop = reservedKeys[prop]) === null || _reservedKeys$prop === void 0 ? void 0 : _reservedKeys$prop.isMediaQuery;
      if (isMediaQuery) {
        if (!responsiveProp) {
          responsiveProp = reservedKeys[prop].key;
        } else {
          isInvalidPropString = true;
          console.warn(`${propString} is invalid property.`);
          return;
        }
      } else {
        gsConvertedPropsPath.push(reservedKeys[prop].key);
      }
    } else if (prop.startsWith('_') || descendants.includes(prop)) {
      gsConvertedPropsPath.push(prop);
    } else {
      console.warn(`${propString} is invalid property.`);
      isInvalidPropString = true;
    }
  });
  if (!isInvalidPropString) {
    if (responsiveProp) {
      gsConvertedPropsPath.unshift(responsiveProp);
    }
    gsConvertedPropsPath.push(propToBeApplied);
  }
  return {
    propsPath: gsConvertedPropsPath,
    isInvalidPropString
  };
};
const checkAndReturnUtilityProp = (prop, propValue, styledSystemProps, descendants, reservedKeys) => {
  if (styledSystemProps[prop]) {
    return {
      propPath: [prop],
      value: propValue
    };
  } else {
    if (prop.startsWith('$')) {
      const reservedKey = prop.slice(1);
      if (reservedKeys[reservedKey]) {
        return {
          propPath: [reservedKeys[reservedKey].key],
          value: propValue
        };
      } else if (descendants.includes(reservedKey)) {
        return {
          propPath: [reservedKey],
          value: propValue
        };
      } else {
        // resolve ${{states/colormode/media}}-***
        const {
          propsPath: sxPropPath,
          isInvalidPropString
        } = getSxPropsPathFromProp(reservedKey, reservedKeys, descendants);
        if (!isInvalidPropString) {
          return {
            propPath: sxPropPath,
            value: propValue
          };
        }
      }
    }
  }
  return {
    prop: prop,
    value: propValue
  };
};
exports.checkAndReturnUtilityProp = checkAndReturnUtilityProp;
const convertUtilityPropsToSX = function (styledSystemProps, descendants, componentProps) {
  let reservedKeys = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _styledSystem.reservedKeys;
  const sxPropsConvertedUtilityProps = {};
  const ignoredProps = {};
  if (Object.keys(componentProps).length === 0) return {
    sxProps: {},
    mergedProps: {}
  };
  Object.keys(componentProps).forEach(prop => {
    const {
      prop: propString,
      propPath,
      value: propValue
    } = checkAndReturnUtilityProp(prop, componentProps[prop], styledSystemProps, descendants, reservedKeys);
    if (propString) {
      ignoredProps[prop] = propValue;
    } else {
      if (propPath && propPath.length > 0) {
        (0, _utils.setObjectKeyValue)(sxPropsConvertedUtilityProps, propPath, propValue);
      }
    }
  });
  const sxPropsConvertedUtilityPropsToVerboseSx = (0, _convertSxToSxVerbosed.convertSxToSxVerbosed)(sxPropsConvertedUtilityProps);
  return {
    sxProps: sxPropsConvertedUtilityPropsToVerboseSx,
    mergedProps: ignoredProps
  };
};
exports.convertUtilityPropsToSX = convertUtilityPropsToSX;
//# sourceMappingURL=convert-utility-to-sx.js.map