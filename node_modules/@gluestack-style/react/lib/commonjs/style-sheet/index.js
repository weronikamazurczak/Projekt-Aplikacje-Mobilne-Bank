"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StyleInjector = exports.GluestackStyleSheet = void 0;
var _resolver = require("../resolver");
var _updateCSSStyleInOrderedResolved = require("../updateCSSStyleInOrderedResolved.web");
var _utils = require("../utils");
var _cssInjector = require("../utils/css-injector");
class StyleInjector {
  #globalStyleMap;
  #toBeInjectedIdsArray;
  #idCounter;
  constructor() {
    this.#globalStyleMap = new Map();
    this.#toBeInjectedIdsArray = [];
    this.#idCounter = 0;
  }
  declare(orderedSXResolved, _wrapperElementId) {
    let _styleTagId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'css-injected-boot-time';
    let extendedConfig = arguments.length > 3 ? arguments[3] : undefined;
    const styleIds = [];
    orderedSXResolved.forEach(styledResolved => {
      var _styledResolved$meta;
      if (styledResolved !== null && styledResolved !== void 0 && (_styledResolved$meta = styledResolved.meta) !== null && _styledResolved$meta !== void 0 && _styledResolved$meta.cssId) {
        this.#globalStyleMap.set(styledResolved.meta.cssId, {
          ...styledResolved,
          type: _wrapperElementId,
          componentHash: _styleTagId,
          id: this.#idCounter,
          extendedConfig
        });
        this.#idCounter++;
        styleIds.push(styledResolved.meta.cssId);
      }
    });
    return styleIds;
  }
  resolve() {
    let cssIds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let CONFIG = arguments.length > 1 ? arguments[1] : undefined;
    let ExtendedConfig = arguments.length > 2 ? arguments[2] : undefined;
    let resolve = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    let declarationType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'boot';
    let componentExtendedConfig = CONFIG;
    if (ExtendedConfig) {
      componentExtendedConfig = (0, _utils.deepMerge)(CONFIG, ExtendedConfig);
    }
    const toBeInjected = {};
    cssIds === null || cssIds === void 0 || cssIds.forEach(cssId => {
      if (this.#globalStyleMap.get(cssId)) {
        var _styledResolved$meta2;
        const styledResolved = this.#globalStyleMap.get(cssId);
        const theme = styledResolved === null || styledResolved === void 0 ? void 0 : styledResolved.original;
        if (resolve) {
          this.resolveComponentTheme(styledResolved, theme, componentExtendedConfig, styledResolved.componentHash, CONFIG, declarationType);
        }
        const type = styledResolved === null || styledResolved === void 0 ? void 0 : styledResolved.type;
        const styleTag = styledResolved === null || styledResolved === void 0 ? void 0 : styledResolved.componentHash;
        const cssRuleset = styledResolved === null || styledResolved === void 0 || (_styledResolved$meta2 = styledResolved.meta) === null || _styledResolved$meta2 === void 0 ? void 0 : _styledResolved$meta2.cssRuleset;
        if (!toBeInjected[type]) {
          toBeInjected[type] = new Map();
        }
        const cummialtiveCssRuleset = toBeInjected[type].get(styleTag);
        if (!cummialtiveCssRuleset) {
          toBeInjected[type].set(styleTag, {
            id: styledResolved.id,
            cssRuleset: cssRuleset ?? ''
          });
        } else {
          toBeInjected[type].set(styleTag, {
            id: cummialtiveCssRuleset === null || cummialtiveCssRuleset === void 0 ? void 0 : cummialtiveCssRuleset.id,
            cssRuleset: (cummialtiveCssRuleset === null || cummialtiveCssRuleset === void 0 ? void 0 : cummialtiveCssRuleset.cssRuleset) + cssRuleset
          });
        }
        if (styledResolved) {
          this.#globalStyleMap.set(styledResolved.meta.cssId, {
            ...styledResolved,
            value: styledResolved === null || styledResolved === void 0 ? void 0 : styledResolved.resolved
          });
        }
      }
    });
    return toBeInjected;
  }
  update(orderResolvedStyleMap) {
    const toBeInjected = {};
    orderResolvedStyleMap.forEach(styledResolved => {
      var _styledResolved$meta3;
      this.#globalStyleMap.set(styledResolved.meta.cssId, styledResolved);
      this.#toBeInjectedIdsArray.push(styledResolved.meta.cssId);
      const type = styledResolved === null || styledResolved === void 0 ? void 0 : styledResolved.type;
      const styleTag = styledResolved === null || styledResolved === void 0 ? void 0 : styledResolved.componentHash;
      const cssRuleset = styledResolved === null || styledResolved === void 0 || (_styledResolved$meta3 = styledResolved.meta) === null || _styledResolved$meta3 === void 0 ? void 0 : _styledResolved$meta3.cssRuleset;
      if (!toBeInjected[type]) {
        toBeInjected[type] = new Map();
      }
      const cummialtiveCssRuleset = toBeInjected[type].get(styleTag);
      if (!cummialtiveCssRuleset) {
        toBeInjected[type].set(styleTag, {
          id: styledResolved.id,
          cssRuleset: cssRuleset ?? ''
        });
      } else {
        toBeInjected[type].set(styleTag, {
          id: cummialtiveCssRuleset === null || cummialtiveCssRuleset === void 0 ? void 0 : cummialtiveCssRuleset.id,
          cssRuleset: (cummialtiveCssRuleset === null || cummialtiveCssRuleset === void 0 ? void 0 : cummialtiveCssRuleset.cssRuleset) + cssRuleset
        });
      }
    });
    return toBeInjected;
  }
  inject() {
    let toBeInjected = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let inlineStyleMap = arguments.length > 1 ? arguments[1] : undefined;
    Object.keys(toBeInjected).forEach(type => {
      toBeInjected[type].forEach((_ref, styleTag) => {
        let {
          id,
          cssRuleset
        } = _ref;
        this.injectStyles(cssRuleset, type, styleTag, inlineStyleMap, id);
      });
    });
  }
  resolveComponentTheme(componentTheme, theme, componentExtendedConfig, componentHashKey, CONFIG) {
    let declarationType = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 'boot';
    const prefixClassName = declarationType === 'inline' ? 'gs' : '';
    componentTheme.resolved = (0, _resolver.StyledValueToCSSObject)(theme, componentExtendedConfig);
    (0, _utils.addThemeConditionInMeta)(componentTheme, CONFIG);

    // delete componentTheme.meta.cssRuleset;

    if (componentTheme.meta && componentTheme.meta.queryCondition) {
      var _resolveTokensFromCon;
      // console.log(
      //   JSON.parse(JSON.stringify(CONFIG)),
      //   componentTheme.meta,
      //   componentTheme.meta.queryCondition
      // );

      const queryCondition = (_resolveTokensFromCon = (0, _utils.resolveTokensFromConfig)(CONFIG, {
        condition: componentTheme.meta.queryCondition
      })) === null || _resolveTokensFromCon === void 0 ? void 0 : _resolveTokensFromCon.condition;
      // console.log(JSON.parse(JSON.stringify(CONFIG)), queryCondition);

      componentTheme.meta.queryCondition = queryCondition;
    }
    const cssData = (0, _updateCSSStyleInOrderedResolved.getCSSIdAndRuleset)(componentTheme, componentHashKey, prefixClassName);
    componentTheme.meta.cssRuleset = cssData.rules.style;
  }
  getStyleMap() {
    return this.#globalStyleMap;
  }
  injectStyles(cssRuleset, _wrapperType, _styleTagId, inlineStyleMap, id) {
    if (cssRuleset) {
      (0, _cssInjector.inject)(`@media screen {${cssRuleset}}`, _wrapperType, _styleTagId, inlineStyleMap, id);
    }
  }
}
exports.StyleInjector = StyleInjector;
const stylesheet = new StyleInjector();
const GluestackStyleSheet = stylesheet;
exports.GluestackStyleSheet = GluestackStyleSheet;
//# sourceMappingURL=index.js.map